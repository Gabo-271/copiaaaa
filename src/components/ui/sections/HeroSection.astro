---
import PrimaryCTA from '@components/ui/buttons/PrimaryCTA.astro'
import SecondaryCTA from '@components/ui/buttons/SecondaryCTA.astro'
import Image from '@components/ui/images/Image.astro'

const {
    title,
    subTitle,
    primaryBtn,
    primaryBtnURL,
    secondaryBtn,
    secondaryBtnURL,
    src,
    alt,
} = Astro.props

interface Props {
    title: string
    subTitle?: string
    primaryBtn?: string
    primaryBtnURL?: string
    secondaryBtn?: string
    secondaryBtnURL?: string
    src?: any
    alt?: string
}
---

<style>
    .logo-avatar {
        transition: transform 0.6s;
        transform-style: preserve-3d;
        cursor: pointer;
    }
    
    .logo-avatar.spinning {
        animation: coinFlip 0.8s ease-in-out;
    }
    
    @keyframes coinFlip {
        0% {
            transform: rotateY(0deg);
        }
        100% {
            transform: rotateY(360deg);
        }
    }
</style>

<section class="mx-auto grid max-w-[85rem] gap-4 px-4 pt-14 pb-6 lg:pt-20 sm:px-6 md:grid-cols-2 md:items-center md:gap-8 lg:px-8 2xl:max-w-full relative overflow-hidden">
    <!-- Matrix Rain Effect - Only visible in dark mode -->
    <canvas id="matrix-canvas" class="absolute inset-0 opacity-0 dark:opacity-30 pointer-events-none transition-opacity duration-500"></canvas>
    
    <div class="relative z-10">
        <h1 class="block text-balance text-3xl font-bold tracking-tight text-neutral-800 dark:text-neutral-200 sm:text-4xl lg:text-6xl lg:leading-tight">
            <Fragment set:html={title} />
        </h1>
        {subTitle && (
            <p class="mt-6 text-pretty text-lg leading-relaxed text-neutral-700 dark:text-white lg:w-4/5">
                {subTitle}
            </p>
        )}

        <div class="mt-7 grid w-full gap-3 sm:inline-flex">
            {primaryBtn && <PrimaryCTA title={primaryBtn} url={primaryBtnURL} />}
            {secondaryBtn && <SecondaryCTA title={secondaryBtn} url={secondaryBtnURL} />}
        </div>
    </div>

    <div class="w-full hidden md:block relative z-10">
        <div class="top-12 overflow-hidden w-full md:ml-4 flex justify-center">
            {src && alt && (
                <div id="logo-avatar" class="logo-avatar relative w-[320px] h-[320px] rounded-full overflow-hidden bg-white dark:bg-neutral-800 p-4 shadow-xl">
                    <Image
                        src={src}
                        alt={alt}
                        class="h-full w-full scale-100 object-contain object-center rounded-full"
                        draggable="false"
                        loading="eager"
                        format="avif"
                        disableBlur={true}
                    />
                </div>
            )}
        </div>
    </div>
</section>

<script>
    const canvas = document.getElementById('matrix-canvas') as HTMLCanvasElement;
    if (canvas) {
        const ctx = canvas.getContext('2d');
        
        // Set canvas size
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // Matrix characters - using binary and some special characters
        const chars = '01';
        const fontSize = 14;
        const columns = canvas.width / fontSize;
        
        // Array to track drop position for each column
        const drops: number[] = [];
        for (let i = 0; i < columns; i++) {
            drops[i] = Math.random() * -100;
        }

        function draw() {
            if (!ctx) return;
            
            // Black background with transparency to create trail effect
            ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Set text style
            ctx.font = fontSize + 'px monospace';
            
            // Draw characters
            for (let i = 0; i < drops.length; i++) {
                // Random character
                const text = chars[Math.floor(Math.random() * chars.length)];
                
                // Gradient color - white to green (Matrix style with bright tips)
                const gradient = ctx.createLinearGradient(0, drops[i] * fontSize, 0, (drops[i] + 1) * fontSize);
                gradient.addColorStop(0, '#ffffff');
                gradient.addColorStop(0.1, '#4ade80');
                gradient.addColorStop(0.5, '#22c55e');
                gradient.addColorStop(1, '#16a34a');
                ctx.fillStyle = gradient;
                
                // Draw the character
                ctx.fillText(text, i * fontSize, drops[i] * fontSize);
                
                // Reset drop to top randomly
                if (drops[i] * fontSize > canvas.height && Math.random() > 0.975) {
                    drops[i] = 0;
                }
                
                drops[i]++;
            }
        }

        // Draw every 50ms
        setInterval(draw, 50);

        // Resize canvas on window resize
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });
    }

    // Logo flip animation
    const logoAvatar = document.getElementById('logo-avatar');
    if (logoAvatar) {
        logoAvatar.addEventListener('click', () => {
            logoAvatar.classList.add('spinning');
            setTimeout(() => {
                logoAvatar.classList.remove('spinning');
            }, 800);
        });
    }
</script>
